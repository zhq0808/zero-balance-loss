# 🎬 冲突可视化器使用指南

## 概述

**双边对决 + 中间真理层** - 这是一个类似Git合并冲突界面的并发问题可视化工具，通过慢动作回放的方式展示两个并发请求如何导致数据丢失。

## 🚀 快速开始

### 步骤1：发起并发攻击

1. 打开主页：http://localhost:8080
2. 设置参数：
   - 初始余额：1000元
   - 并发数：10-20
   - 每次扣款：10元
3. **确保处于无锁模式**（🔓 无锁）
4. 点击"🚀 发起并发攻击"

### 步骤2：打开可视化器

1. 在主页点击"🎬 打开可视化器"按钮
2. 或直接访问：http://localhost:8080/visualizer

### 步骤3：观看冲突回放

1. 点击"🔄 加载最近冲突"按钮
2. 点击"▶️ 播放动画"按钮
3. 观看4个阶段的慢动作回放

## 🎭 界面布局

```
┌────────────────────────────────────────────────────────┐
│                  冲突可视化器标题                        │
└────────────────────────────────────────────────────────┘

┌──────────────┬──────────────┬──────────────┐
│  Goroutine A │   Database   │  Goroutine B │
│   (蓝色)      │   (绿色)      │   (黄色)      │
├──────────────┼──────────────┼──────────────┤
│ Step 1: Read │              │ Step 1: Read │
│ Step 2: Calc │  💾 余额值    │ Step 2: Calc │
│ Step 3: Write│              │ Step 3: Write│
├──────────────┼──────────────┼──────────────┤
│ 数据气泡      │ ⚠️ 警告框    │ 数据气泡      │
│ 请求信息      │ 冲突统计      │ 请求信息      │
└──────────────┴──────────────┴──────────────┘
```

## 🎬 四阶段动画详解

### 阶段一：并发读取（0-2秒）

**视觉效果**：
- 左侧A的气泡变为蓝色，显示"读取中..."
- 右侧B的气泡变为蓝色，显示"读取中..."
- 两者几乎同时读取

**数据展示**：
```
Goroutine A: local_balance = 1000元
Goroutine B: local_balance = 1000元
Database: 1000元
```

**关键点**：✅ 两个请求读到了**相同的值**！

---

### 阶段二：业务计算（2-3.5秒）

**视觉效果**：
- A和B的气泡都变为**黄色**
- 显示"正在计算..."
- 中间数据库保持不变

**数据展示**：
```
Goroutine A: 1000 - 10 = 990元
Goroutine B: 1000 - 10 = 990元
Database: 1000元 (未变化)
```

**关键点**：⚠️ 这是**竞态窗口**！两者都在计算，但都基于相同的旧值。

---

### 阶段三：A率先写入（3.5-5秒）

**视觉效果**：
- A的气泡变为绿色，显示"写入成功！"
- 数据库的数字动画翻滚：1000 → 990
- 数据库变绿色闪烁

**数据展示**：
```
Goroutine A: ✅ 写入 990元
Database: 990元 (已更新)
Goroutine B: 还在计算...
```

**关键点**：✅ A成功写入，数据库现在是990元

---

### 阶段四：B覆盖写入（5秒后）

**视觉效果**：
1. **红色警告框弹出**（最重要！）
2. B的气泡变为红色，显示"❌ 覆盖写入！"
3. 数据库闪烁红色
4. 数据库数字：990 → 990（或其他值）

**警告框内容**：
```
⚠️ Stale Data 检测！

B的计算基准: 1000元
DB当前实际值: 990元
基准已过期！覆盖即将发生！
```

**数据展示**：
```
Goroutine A: 已完成 (写入990)
Goroutine B: ❌ 写入 990元 (覆盖了A的结果！)
Database: 990元 (应该是980元)
```

**冲突统计**：
```
📊 冲突统计
初始值: 10.00元
A写入后: 9.90元
B写入后: 9.90元
理论值: 9.80元
丢失金额: 0.10元 ⚠️
```

**关键点**：🔥 **Lost Update 发生**！B使用过时的数据覆盖了A的写入结果！

## 🎯 核心教育价值

### 为什么会丢失？

1. **A读取**：balance = 1000
2. **B读取**：balance = 1000（读到了相同的旧值）
3. **A计算**：1000 - 10 = 990
4. **B计算**：1000 - 10 = 990（基于旧值计算）
5. **A写入**：balance = 990 ✅
6. **B写入**：balance = 990 ❌（覆盖了A的结果）

**期望结果**：1000 - 10 - 10 = 980元  
**实际结果**：990元  
**丢失金额**：10元

### Stale Data（过期数据）

**定义**：B在读取时拿到的数据（1000）在它写入时已经过期了（实际已经是990）。

**类比**：
- 就像拿着旧地图（1000）去找宝藏
- 到达时发现地图已经不准了（实际是990）
- 但还是按旧地图的指示挖宝（写990）
- 把别人刚放进去的宝贝（A写的990）给扔了

## 🔧 操作按钮说明

### 🔄 加载最近冲突
- 从后端获取最近一次捕获的冲突快照
- 如果没有数据，会提示先发起并发攻击

### ▶️ 播放动画
- 启动4阶段慢动作回放
- 总时长约6秒
- 自动按顺序播放

### 🗑️ 清除数据
- 清空后端的冲突快照
- 清空当前显示的数据
- 准备加载新的冲突

## 💡 使用技巧

### 1. 对比实验

**步骤A - 无锁模式**（演示问题）：
1. 主页切换到**无锁模式**（🔓）
2. 发起并发攻击
3. 打开可视化器
4. 观察红色警告和数据丢失

**步骤B - 加锁模式**（演示修复）：
1. 主页切换到**加锁模式**（🔒）
2. 发起并发攻击
3. 打开可视化器
4. 观察：
   - 没有红色警告
   - B等待A完成
   - 数据正确

### 2. 多次观看

- 动画可以反复播放
- 每次播放帮助理解不同细节
- 重点关注：
  - 阶段二：黄色计算期（竞态窗口）
  - 阶段四：红色警告（Stale Data）

### 3. 教学演示

1. **引入问题**：先播放无锁模式的动画
2. **分析原因**：暂停在阶段四，详细讲解警告框
3. **提出解决方案**：讲解加锁的必要性
4. **对比验证**：播放加锁模式的动画

## 🎓 学习要点

### 关键概念

1. **竞态条件（Race Condition）**
   - 两个请求在阶段二同时计算
   - 都基于相同的旧值

2. **Lost Update（丢失更新）**
   - A的更新被B覆盖
   - 最终结果少扣了一次款

3. **Stale Data（过期数据）**
   - B读取的值在写入时已经过期
   - 这是问题的根源

4. **Critical Section（临界区）**
   - Read → Calculate → Write 整个过程
   - 需要原子性保护

### 为什么需要锁？

**无锁的问题**：
```
时间线：
T1: A读(1000) → B读(1000) → A算(990) → B算(990) → A写(990) → B写(990)
                    ↑ 读到相同值                                  ↑ 覆盖写入
```

**加锁的修复**：
```
时间线：
T1: A获取锁 → A读(1000) → A算(990) → A写(990) → A释放锁
T2:                                           → B获取锁 → B读(990) → B算(980) → B写(980) → B释放锁
```

## 🐛 故障排查

### 问题：显示"暂无冲突数据"

**原因**：还没有发起过并发攻击

**解决**：
1. 返回主页：http://localhost:8080
2. 确保无锁模式
3. 发起并发攻击
4. 重新加载可视化器

### 问题：动画不播放

**原因**：没有先加载数据

**解决**：
1. 先点击"🔄 加载最近冲突"
2. 等待提示"加载成功"
3. 再点击"▶️ 播放动画"

### 问题：数据显示异常

**解决**：
1. 点击"🗑️ 清除数据"
2. 返回主页重新发起攻击
3. 重新加载数据

## 📚 扩展学习

### 进阶话题

1. **MVCC（多版本并发控制）**
   - 数据库如何解决这个问题
   - 乐观锁 vs 悲观锁

2. **分布式场景**
   - 单机锁在分布式环境失效
   - 需要分布式锁（Redis、Zookeeper）

3. **数据库锁**
   - 行锁：`SELECT FOR UPDATE`
   - 乐观锁：版本号机制

### 相关文档

- [主项目README](../README.md)
- [测试清单](../TESTING_CHECKLIST.md)
- [Docker部署](../DOCKER.md)

## 🎉 总结

这个可视化器通过**慢动作回放 + 三列对比 + 红色警告**的方式，让抽象的并发问题变得具象可见：

- ✅ 看得见：三列布局清晰展示三个视角
- ✅ 懂得了：四阶段动画逐步揭示问题
- ✅ 记得住：红色警告强化"Stale Data"概念

这是理解并发问题的最佳入门工具！🚀
