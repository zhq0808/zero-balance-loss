# ⚔️ 并发冲突可视化器 - 快速上手指南

## 🎯 核心功能

### 双边对决 + 中间真理层
- 🔵 **左侧**：Goroutine A（先到达的请求）
- 💾 **中间**：Database（共享数据真相）
- 🟡 **右侧**：Goroutine B（后到达的请求）

### 四阶段慢动作回放
1. **阶段1 - 并发读取**：两者几乎同时读到相同的旧值
2. **阶段2 - 业务计算**：⚠️ 竞态窗口！都基于旧值计算
3. **阶段3 - A先写入**：A成功更新数据库
4. **阶段4 - B覆盖写入**：🔥 Stale Data！B用旧值覆盖A的结果

---

## 🚀 快速开始（3步）

### 步骤1：发起并发攻击（主页）

访问：http://localhost:8080

```
1. 设置初始余额：1000元
2. 设置并发数：10
3. 设置每次扣款：10元
4. 确保无锁模式（🔓）
5. 点击"🚀 发起并发攻击"
```

**重要**：并发数 = 同时运行的协程数，每个协程请求次数 = 每个协程发起的请求数
- 总请求数 = 并发数 × 每个协程请求次数
- 例如：10 × 10 = 100次请求

### 步骤2：打开可视化器

点击主页的"🎬 打开可视化器"按钮

或直接访问：http://localhost:8080/visualizer

### 步骤3：观看冲突回放

```
1. 点击"🔄 加载最近冲突"
2. 选择播放方式：
   - ▶️ 自动播放（推荐）
   - ⏭️ 手动步进
```

---

## 🎮 控制按钮说明

### 基础控制
| 按钮 | 功能 | 说明 |
|------|------|------|
| 🔄 加载最近冲突 | 从后端获取数据 | 首次使用必须点击 |
| ▶️ 自动播放 | 开始自动回放 | 每1.5秒切换一个阶段 |
| ⏸️ 暂停 | 暂停自动播放 | 可随时暂停查看细节 |
| ⏭️ 下一步 | 前进一个阶段 | 手动控制节奏 |
| ⏮️ 上一步 | 返回上一阶段 | 重复观看 |
| 🗑️ 清除数据 | 清空快照 | 准备加载新数据 |

### 阶段跳转
点击阶段按钮直接跳转：
- **阶段0**：初始状态
- **阶段1**：并发读取
- **阶段2**：业务计算
- **阶段3**：A写入
- **阶段4**：B写入（冲突！）

---

## ⏱️ 时间线解读

### 显示内容
每个Goroutine都显示精确的时间线：

```
⏱️ 时间线 (Goroutine A)
─────────────────────────────
读取时间: 00:20:11.123
计算开始: 00:20:11.125 (+2.45ms)
计算结束: 00:20:11.135 (+12.50ms)
写入时间: 00:20:11.140 (+17.80ms)
```

### 时间格式说明
- **绝对时间**：HH:MM:SS.mmm（精确到毫秒）
- **相对时间**：(+XX.XXms) 相对于首次读取的时间差
- **⚠️ 重点**：通过相对时间可以看出操作的重叠程度

### 关键指标
- **读取时间差 < 5ms**：高概率并发冲突
- **计算重叠时间**：竞态窗口大小
- **A写入 vs B读取**：如果B读取在A写入之前，必然冲突

---

## 📝 操作历史记录

### 显示位置
每个Goroutine列底部都有"📝 操作历史"面板

### 记录内容
按时间顺序显示所有操作：

```
📝 操作历史 (Goroutine A)
─────────────────────────────
T+0.00ms (00:20:11.123)
读取余额: 470.00元
请求ID: 021cca41

T+2.45ms (00:20:11.125)
开始计算

T+12.50ms (00:20:11.135)
完成计算: 460.00元
新值: 460.00元

T+17.80ms (00:20:11.140)
写入数据库: 460.00元
写入值: 460.00元
```

### 颜色标识
- 🔵 **蓝色背景**：Goroutine A的操作
- 🟡 **黄色背景**：Goroutine B的操作
- 🔴 **红色标记**：冲突操作（覆盖写入）

---

## 🎬 使用场景示例

### 场景1：教学演示

**教师操作流程**：
```
1. 讲解并发问题理论（5分钟）
2. 主页发起攻击，展示余额丢失（2分钟）
3. 打开可视化器，加载冲突数据（1分钟）
4. 使用手动步进，逐阶段讲解（10分钟）
   ├─ 阶段1：强调"同时读取"
   ├─ 阶段2：指出"竞态窗口"
   ├─ 阶段3：A的正确更新
   └─ 阶段4：弹出警告框，讲解Stale Data
5. 切换加锁模式，对比演示（5分钟）
```

### 场景2：自主学习

**学生操作流程**：
```
1. 阅读文档理解概念
2. 自己发起并发攻击
3. 观看自动播放（快速了解）
4. 使用手动步进（深入理解）
5. 反复查看阶段4的警告框
6. 尝试加锁模式对比
```

### 场景3：问题排查

**开发者操作流程**：
```
1. 发现生产环境余额不对
2. 本地复现并发场景
3. 查看可视化器的时间线
4. 分析操作历史找到冲突点
5. 确认是Lost Update问题
6. 设计解决方案（加锁/版本号）
```

---

## 🎯 关键时刻观察点

### ⚠️ 阶段1 - 并发读取
**看什么**：
- A和B的读取时间差
- 两者读到的值是否相同
- 时间差越小，冲突概率越高

**理解**：
> 如果两个请求几乎同时读取，它们会读到相同的旧值

### ⚠️ 阶段2 - 业务计算
**看什么**：
- 黄色气泡表示"正在计算"
- 数据库保持不变
- 两者计算结果相同

**理解**：
> 这是竞态窗口！两者都基于相同的旧值计算新值

### ⚠️ 阶段4 - B覆盖写入（最重要！）
**看什么**：
- 🔴 红色警告框弹出
- 警告内容：B的基准 vs DB当前值
- "Stale Data"字样
- 数据库数字闪烁红色

**理解**：
> B使用过期的数据（1000）去更新已经变化的数据库（990），导致A的更新丢失

---

## 📊 冲突统计面板

位置：中间Database列底部

显示内容：
```
📊 冲突统计
初始值: 10.00元
A写入后: 9.90元
B写入后: 9.90元  ← 应该是9.80元
理论值: 9.80元
丢失金额: 0.10元  ← 🔥 这就是Lost Update
```

---

## 💡 常见问题

### Q1：显示"暂无冲突数据"
**原因**：还没有发起并发攻击

**解决**：
1. 返回主页（http://localhost:8080）
2. 确保**无锁模式**（🔓）
3. 发起并发攻击
4. 重新加载可视化器

### Q2：为什么有时候不显示冲突？
**原因**：加锁模式下，不会产生冲突

**解决**：
- 确认主页的锁图标是🔓（无锁）
- 加锁模式🔒下，请求完全串行，无冲突

### Q3：如何看出是"同时"请求？
**方法**：
1. 查看时间线的相对时间
2. 如果A和B的读取时间差 < 5ms，基本同时
3. 查看操作历史的时间顺序

### Q4：动画播放太快/太慢？
**调整**：
- 目前自动播放：1.5秒/阶段
- 建议使用手动步进，自己控制节奏
- 可以暂停在关键阶段仔细观察

---

## 🎓 学习路径

### 初级（理解问题）
1. ✅ 观看自动播放（2分钟）
2. ✅ 查看阶段4的红色警告（1分钟）
3. ✅ 理解"Stale Data"概念（5分钟）

### 中级（深入分析）
1. ✅ 手动步进查看每个阶段（10分钟）
2. ✅ 研究时间线，计算时间差（10分钟）
3. ✅ 对比加锁/无锁模式（10分钟）

### 高级（问题解决）
1. ✅ 分析操作历史，找出冲突根源（15分钟）
2. ✅ 思考其他解决方案（乐观锁、数据库锁）（20分钟）
3. ✅ 扩展到分布式场景（30分钟）

---

## 🔗 相关资源

- **主项目README**：[README.md](../README.md)
- **详细使用指南**：[CONFLICT_VISUALIZER_GUIDE.md](./CONFLICT_VISUALIZER_GUIDE.md)
- **测试清单**：[TESTING_CHECKLIST.md](./TESTING_CHECKLIST.md)

---

## 🎉 总结

这个可视化器通过**三列布局 + 四阶段动画 + 精确时间 + 操作历史**，让你能够：

- ✅ **看得见**：直观的三列对比
- ✅ **控得住**：完整的步进控制
- ✅ **查得到**：精确的时间记录
- ✅ **懂得透**：详细的操作历史
- ✅ **记得牢**：红色警告强化印象

现在开始你的并发学习之旅吧！🚀
