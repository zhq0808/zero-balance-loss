# 交互式代码控制台使用指南

## 功能概述

交互式代码控制台是一个教育性功能，允许用户在运行时动态切换"无锁模式"和"加锁模式"，直观地观察并发控制对系统行为的影响。

## 界面说明

### 1. 代码展示区

控制台显示两个版本的代码实现：

**左侧 - 无锁版本 (UNLOCKED)**
- 函数：`DeductBalance`
- 特点：没有并发控制，存在竞态条件
- 问题：多个goroutine同时读取余额 → 处理业务 → 写回余额，导致余额丢失

**右侧 - 加锁版本 (LOCKED)**
- 函数：`DeductBalanceWithLock`
- 特点：使用 `sync.Mutex` 互斥锁保护临界区
- 优点：同一时刻只允许一个goroutine执行扣款逻辑，确保线程安全

### 2. 模式切换开关

**位置**：代码控制台右上角

**组件**：
- Toggle开关：点击切换加锁/无锁模式
- 状态标签：
  - 🔓 无锁 (红色背景)
  - 🔒 已加锁 (绿色背景)

**工作原理**：
- 切换开关时，前端通过WebSocket向后端发送模式切换请求
- 后端立即切换执行策略，并广播给所有连接的客户端
- 所有客户端界面同步更新，高亮当前使用的代码版本

## 使用流程

### 场景1：演示并发问题

1. **确保系统处于无锁模式**
   - 开关处于左侧（关闭状态）
   - 状态显示 "🔓 无锁"
   - 左侧代码块高亮显示

2. **发起并发攻击**
   - 设置并发数：50
   - 每次扣款：10元
   - 点击 "🚀 发起并发攻击"

3. **观察结果**
   - 余额水位图：实际余额线低于理论余额线
   - 统计面板：显示丢失金额 > 0
   - 追踪列表：可以看到多个请求在同一时间读取到相同余额

### 场景2：验证加锁修复效果

1. **切换到加锁模式**
   - 点击右上角Toggle开关
   - 状态变为 "🔒 已加锁"
   - 右侧代码块高亮显示

2. **重置余额**
   - 点击 "重置余额" 按钮
   - 页面刷新，余额恢复初始值

3. **再次发起攻击**
   - 使用相同的参数设置
   - 点击 "🚀 发起并发攻击"

4. **对比结果**
   - 余额水位图：实际余额线与理论余额线完全重合
   - 统计面板：丢失金额 = 0.00元
   - 响应时间略有增加（锁竞争的代价）
   - 追踪列表：请求串行执行，无余额读取冲突

## 技术实现

### 前端技术栈

- **Highlight.js**：代码语法高亮
- **CSS动画**：代码块切换的视觉反馈
- **WebSocket**：实时模式同步

### 后端API

#### 1. 切换模式 (POST /api/mode/switch)

**请求体**：
```json
{
  "use_lock": true  // true=加锁, false=无锁
}
```

**响应**：
```json
{
  "code": 200,
  "message": "mode switched successfully",
  "data": {
    "mode": "locked",
    "use_lock": true
  }
}
```

#### 2. 获取当前模式 (GET /api/mode/status)

**响应**：
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "mode": "unlocked",
    "use_lock": false
  }
}
```

### WebSocket消息

**服务端广播（mode_changed）**：
```json
{
  "type": "mode_changed",
  "data": {
    "mode": "locked",
    "use_lock": true
  },
  "timestamp": 1738483200000
}
```

## 性能对比

### 无锁模式 (UNLOCKED)

| 指标 | 典型值 |
|------|--------|
| 并发数 | 50 |
| 请求成功率 | ~100% |
| 余额正确性 | ❌ 不正确 |
| 平均响应时间 | ~10ms |
| 余额丢失率 | 20-40% |

**问题原因**：
```
请求A: 读取余额=1000 → 处理10ms → 扣除10 → 写回990
请求B: 读取余额=1000 → 处理10ms → 扣除10 → 写回990  ← 丢失A的扣款
```

### 加锁模式 (LOCKED)

| 指标 | 典型值 |
|------|--------|
| 并发数 | 50 |
| 请求成功率 | ~100% |
| 余额正确性 | ✅ 完全正确 |
| 平均响应时间 | ~15ms |
| 余额丢失率 | 0% |

**保护机制**：
```
请求A: 获取锁 → 读取余额=1000 → 扣除10 → 写回990 → 释放锁
请求B: 等待锁 → 获取锁 → 读取余额=990 → 扣除10 → 写回980 → 释放锁 ✓
```

## 教育价值

### 学习目标

1. **直观理解竞态条件**
   - 看到实际的并发bug
   - 理解"读-改-写"竞态的危害

2. **掌握互斥锁使用**
   - 学习 `sync.Mutex` 的正确用法
   - 理解 Lock/Unlock 的配对原则
   - 体会 defer 的最佳实践

3. **权衡性能与正确性**
   - 观察锁带来的性能开销（~50%）
   - 理解为什么金融系统必须使用锁
   - 学习如何优化锁粒度

### 扩展实验

**实验1：增大并发窗口**
- 修改代码中的 `time.Sleep(10 * time.Millisecond)` 为 100ms
- 观察余额丢失率显著增加

**实验2：锁粒度优化**
- 尝试只对写操作加锁，读操作不加锁
- 发现问题依然存在（读写不隔离）

**实验3：数据库行锁**
- 使用 `SELECT ... FOR UPDATE` 替代应用层锁
- 对比性能和正确性

## 常见问题

### Q1：为什么切换模式后需要重置余额？

**A**：不需要强制重置，但建议重置以进行公平对比。如果不重置：
- 无锁模式可能已经造成余额丢失
- 加锁模式会基于错误的初始值继续扣款
- 难以清晰对比两种模式的差异

### Q2：能否在攻击进行中切换模式？

**A**：可以，系统支持热切换。但注意：
- 正在执行的请求不会中断
- 新模式立即生效于后续请求
- 可能看到图表中的"过渡期"现象

### Q3：为什么加锁后响应时间变长？

**A**：锁竞争导致的排队时间：
- 50个并发请求需要串行执行
- 每个请求 10ms，总等待时间累加
- 这是正确性的必要代价

### Q4：生产环境如何优化？

**A**：几种优化策略：
1. **减小锁粒度**：只锁关键代码段
2. **读写锁**：用 `sync.RWMutex` 优化读多写少场景
3. **分布式锁**：用Redis/etcd实现跨服务的锁
4. **乐观锁**：用版本号+CAS避免悲观锁
5. **分库分表**：降低单表锁竞争

## 代码位置

- 前端代码：`web/index.html` (Line 580-700)
- 后端服务：`service/account_service.go`
  - 无锁版本：`DeductBalance` (Line 15-50)
  - 加锁版本：`DeductBalanceWithLock` (Line 52-87)
- API路由：`api/handler.go`
  - 模式切换：`switchModeHandler` (Line 410-450)
  - 状态查询：`getModeStatusHandler` (Line 452-470)

## 总结

交互式代码控制台通过"看得见"的方式，让并发编程的抽象概念变得具体：

- ❌ **无锁 = 快但错** → 高性能，低正确性
- ✅ **加锁 = 慢但对** → 低性能，高正确性

在金融、电商等涉及资金的场景中，**正确性永远是第一位的**。这个工具帮助开发者深刻理解这一原则。
