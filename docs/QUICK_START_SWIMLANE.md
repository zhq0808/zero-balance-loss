# 🚀 泳道图可视化快速上手指南

## 预览效果

访问 http://localhost:8080 即可看到全新的并发时序泳道图！

## 快速体验步骤

### 1️⃣ 启动项目

```bash
# 确保Docker和数据库已启动
docker-compose up -d

# 启动Go服务
go run main.go
```

### 2️⃣ 打开浏览器

访问：http://localhost:8080

### 3️⃣ 重置余额

1. 在"控制台"区域，设置初始余额为 **1000元**
2. 点击 **"重置余额"** 按钮

### 4️⃣ 发起并发攻击（无锁模式）

**重要**：确保"加锁模式"开关处于**关闭**状态（🔓 无锁）

设置参数：
- **初始余额**：1000元
- **并发数**：10
- **每次扣款**：10元  
- **每个协程请求次数**：5

点击 **"🚀 发起并发攻击"** 按钮

### 5️⃣ 观察泳道图

**位置**：页面中部有一个大的图表区域，标题为"🏊 并发时序泳道图（微观甘特图）"

**你会看到**：

```
横轴 = 时间（毫秒）
纵轴 = 请求ID（每个请求一条泳道）

请求1: [🔵 读] ----[🟡 计算]---- [🟢 写]
请求2:     [🔵 读] ----[🟡 计算]---- [🟢 写]
请求3:         [🔵 读] ----[🟡 计算]---- [🟢 写]
              ↑ 红色半透明区域 = 竞态窗口 ↑
```

**图例说明**：
- 🔵 **蓝色块**：读取数据库操作
- 🟡 **黄色块**：业务计算/延迟阶段（这是竞态发生的温床！）
- 🟢 **绿色块**：写入数据库操作
- 🔴 **红色区域**：检测到的竞态窗口（多个请求的黄色块重叠）

### 6️⃣ 关键观察点

#### ⚠️ 问题现象：

1. **竞态窗口出现**：
   - 当多个请求的黄色块（计算阶段）在时间上重叠时，系统会用红色半透明区域标记
   - 这表示多个请求同时读到了相同的旧值

2. **余额丢失**：
   - 查看页面右上角的统计面板
   - "当前余额" vs "理论余额" 会出现差异
   - "丢失金额" 显示为负数

3. **时序冲突**：
   - 点击图表中的色块可以查看详细信息
   - 观察不同请求读到相同余额值的情况

### 7️⃣ 对比实验：切换到加锁模式

1. 点击页面顶部代码控制台区域的 **"加锁模式"** 开关
2. 确认状态变为：🔒 加锁
3. 再次点击 **"重置余额"**
4. 再次点击 **"🚀 发起并发攻击"**

#### ✅ 观察改善：

```
请求1: [🔵 读1000] ----[🟡 计算]---- [🟢 写990]
请求2:                                     [🔵 读990] ----[🟡 计算]---- [🟢 写980]
请求3:                                                                         [🔵 读980] ----[🟡 计算]---- [🟢 写970]
```

**关键变化**：
- ❌ **无竞态窗口**：没有红色区域，黄色块完全不重叠
- ✅ **完全串行**：请求依次执行，互不干扰
- ✅ **余额准确**：当前余额 = 理论余额，无丢失

### 8️⃣ 交互功能

**刷新按钮**：
- 点击 **"🔄 刷新"** 手动更新泳道图数据
- 图表会自动每2秒刷新一次

**清空按钮**：
- 点击 **"🗑️ 清空"** 清除历史数据
- 重新开始观察新的请求

**鼠标交互**：
- **悬停**：鼠标移到色块上查看详细信息
  - 请求ID
  - 操作类型（read/compute/write）
  - 余额值
  - 耗时（毫秒）

## 📊 教学演示建议

### 演示流程

1. **引入问题**（5分钟）
   - 展示无锁模式下的并发攻击
   - 指出余额丢失现象
   - 提问：为什么会丢失？

2. **可视化分析**（10分钟）
   - 打开泳道图
   - 详细解释三个阶段：读、计算、写
   - 重点标注黄色计算阶段
   - 指出红色竞态窗口的含义

3. **问题根源**（5分钟）
   - 用泳道图说明：
     - 请求A读到1000
     - 请求B也读到1000（此时A还在计算）
     - A写入990
     - B写入990（覆盖了A的结果！）
   - 这就是"Lost Update"问题

4. **解决方案**（10分钟）
   - 切换到加锁模式
   - 再次发起攻击
   - 对比泳道图：无重叠、完全串行
   - 验证余额：无丢失

5. **深入讨论**（10分钟）
   - 讨论锁的代价：性能下降
   - 观察泳道图：加锁后总时间变长
   - 引导思考：是否还有其他方案？
     - 乐观锁（版本号）
     - 数据库锁（SELECT FOR UPDATE）
     - 队列化处理

## 🎯 学习要点

### 通过泳道图学到什么？

1. **并发不等于并行**：
   - 看到请求虽然"同时"发起，但执行有先后
   - 理解时间片的概念

2. **竞态窗口**：
   - 黄色块重叠 = 危险信号
   - 这个时间窗口内，多个操作基于相同的旧数据

3. **互斥锁的作用**：
   - 强制串行化临界区
   - 牺牲并发性换取正确性

4. **性能权衡**：
   - 无锁：快但可能错
   - 加锁：慢但一定对
   - 实际项目需要权衡

## 🔧 故障排查

### 问题：泳道图不显示

**检查**：
1. 打开浏览器控制台（F12）
2. 查看是否有JavaScript错误
3. 检查网络请求：`/api/swimlane` 是否返回200

**解决**：
```bash
# 重启服务
# 按 Ctrl+C 停止
go run main.go
```

### 问题：泳道图显示为空

**原因**：还没有发起过请求

**解决**：
1. 点击"重置余额"
2. 点击"发起并发攻击"
3. 等待2秒（自动刷新）

### 问题：红色竞态窗口不出现

**可能原因**：
1. 并发数太低（建议≥10）
2. 处于加锁模式（切换到无锁模式）
3. 请求间隔太大

**解决**：
- 增加并发数到20-50
- 确保关闭加锁模式
- 清空历史数据重新测试

## 📚 相关文档

- [详细实现文档](./SWIMLANE_VISUALIZATION.md)
- [测试清单](./TESTING_CHECKLIST.md)
- [Docker部署](./DOCKER.md)

## 💡 提示

**最佳演示效果**：
- 使用大屏幕或投影仪
- 并发数设置为 10-20（太多会显得拥挤）
- 每次扣款金额不要太小（便于计算）
- 可以录屏保存演示过程

**高级玩法**：
- 同时打开多个浏览器窗口，模拟分布式场景
- 调整 `time.Sleep(10 * time.Millisecond)` 参数改变竞态窗口大小
- 尝试实现其他并发控制策略（如乐观锁）

---

享受探索并发世界的乐趣！🎉
